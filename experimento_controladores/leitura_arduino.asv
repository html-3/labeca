% Script para comparar sinais e calcular o ganho entre os dados do osciloscópio e Arduino Due

close all;

% Carregar os dados do osciloscópio (CSV)
osc_data = readmatrix('ard_test.csv'); % Substituir pelo nome do seu arquivo
tempo_osc = osc_data(:, 1); % Primeira coluna: tempo (s)
sinal_osc = osc_data(:, 2); % Segunda coluna: amplitude (V)

% Carregar os dados do Arduino Due (MAT)
arduino_data = load('out.mat'); % Substituir pelo nome do seu arquivo
tempo_arduino = arduino_data.out.ScopeData.time; 
sinal_arduino = double(arduino_data.out.ScopeData.signals.values); 

ard_signal = zeros(1, size(sinal_arduino,3));

for i = 1:size(sinal_arduino,3)
    
    ard_signal(i) = sinal_arduino(:,:,i);
    
end

% Converter os valores de 12 bits para tensão (0 a 3.3V)
sinal_arduino_v = (ard_signal ./ 4095) * 3.3; % 4095 é 2^12 - 1

% Ajustar o tempo (opcional)
% Se necessário, alinhe os sinais em tempo
[tempo_osc, sinal_osc, tempo_arduino, sinal_arduino_v] = alinharSinais(tempo_osc, sinal_osc, tempo_arduino, sinal_arduino_v);

% Interpolar os sinais para comparação (mesma base de tempo)
tempo_comum = linspace(max(tempo_osc(1), tempo_arduino(1)), min(tempo_osc(end), tempo_arduino(end)), 1000);
sinal_osc_interp = interp1(tempo_osc, sinal_osc, tempo_comum);
sinal_arduino_interp = interp1(tempo_arduino, sinal_arduino_v, tempo_comum);

% Calcular o ganho (sinal Arduino / sinal Osciloscópio)
ganho = sinal_arduino_interp ./ sinal_osc_interp;

% Plotar os resultados
figure;
plot(tempo_comum, sinal_osc_interp, 'b', 'LineWidth', 1.5); 
hold on;
plot(tempo_comum, sinal_arduino_interp, 'r--', 'LineWidth', 1.5);
xlabel('Tempo (s)');
ylabel('Amplitude (V)');
title('Comparação dos Sinais');
legend('Osciloscópio', 'Arduino Due');
grid on;

figure;
plot(arduino_tempi, sinal_arduino_v, 'm', 'LineWidth', 1.5);
xlabel('Tempo (s)');
ylabel('Ganho');
title('Ganho entre os Sinais (Arduino / Osciloscópio)');
grid on;

ganho_medio = mean(ganho, 'omitnan');
disp(['Ganho médio: ', num2str(ganho_medio)]);

% Função auxiliar para ajustar os sinais para começar na mesma base de tempo
function [t1_al, y1_al, t2_al, y2_al] = alinharSinais(t1, y1, t2, y2)

    t_inicio = max(t1(1), t2(1));
    t_fim = min(t1(end), t2(end));
    idx1 = (t1 >= t_inicio) & (t1 <= t_fim);
    idx2 = (t2 >= t_inicio) & (t2 <= t_fim);
    t1_al = t1(idx1);
    y1_al = y1(idx1);
    t2_al = t2(idx2);
    y2_al = y2(idx2);
end
